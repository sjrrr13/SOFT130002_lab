# Lab6设计文档
19302010035佘家瑞

## 第一题
在函数`testTime()`内部新建了一个函数`count()`，在`count()`内部声明计数变量，然后返回`count()`函数，实现了闭包。

## 第二题
1. 判断电话号码的正则表达式：`/1[0-9]{10}/`。第1位数字是1，然后0-9可以出现10次，一共是11位数字。
2. 判断邮箱的正则表达式：`/[A-Za-z0-9]\w{2,}@(\w{2,}\.){1,2}\w{2,4}/`。第一位是字母或数字，接下来是字母数字或下划线，并且`@`号前面应该有3个以上字符。然后是1个或2个`xx.`，最后是2到4个字符结尾。

## 第三题
用`" "`分割字符串存入一个数组，对数组的第一个到倒数第二个元素进行遍历。每次循环都创建一个**RegExp对象**，将这次循环的数组元素作为RegExp对象的模式，且忽略大小写，然后来判断后一个数组元素是否符合这个模式，若符合，则将这两个元素`add`到一个Set对象中。循环结束或者Set对象内有十个元素后打印结果。

## 第四题
将`actualInput`每个字符都分开，并存入一个数组；将`wantInput`全部转换成大写格式（键盘上都是大写格式）。对数组进行遍历，对每个元素都以该元素为模式，忽略大小写并且全局搜索建立一个**RegExp对象**，将大写格式的`wantInput`里符合该RegExp对象的字符全部替换成空字符。循环结束后，剩下的就是坏掉的键盘字符，将其分割成数组并转换成Set集合即可。

## 第五题
用`trim()`方法去掉字符串前后的空格，再用空格分隔字符串，存入一个数组。对数组进行遍历，若第i个元素不是空字符串，则将第i个元素`unshift()`到一个数组，最后将数组`join(" ")`转换成字符串即可。

## 第六题
新建一个空对象；将传入的数组nums进行转换：`temp = nums.map(x => target - x)`，对nums进行遍历。对第i个元素，将temp[i]作为属性，i作为值传入建好的对象，如果该对象的nums[i]属性不是`undefined`，则打印该对象的nums[i]属性和i即可。

## 第七题
对字符串进行遍历。将第1个字符的`[字符值,下标+1]`传入一个map中，从第二次循环开始，检查map中是否有该次循环的字符，如果有，用这次循环的次序值减去map中该字符对应值并+1得到差值，再次将这组`[字符值,下标+1]`传入map，最后比较得出最大的差值即可。

## 第八题&对继承的理解
1. 借助构造函数的继承：在子函数内部调用父函数，即`SuperType.call(this)`。可以传参，但无法实现构造函数服用。
2. 原型链继承：将子函数的原型设成父函数的实例，即`SubType.prototype = new SuperType()`。问题是所有子类型的实例共享父类型实例的属性。
3. `Object.create()`：即`SubType.prototype = Object.create(SuperType.prototype)`。

## Map、Set、Array的理解
1. Map：对数组进行一一对应的操作并返回一个数组。我理解为`arr.map(x => f(x))`，即`arr`是定义域，`map()`方法返回的数组是值域，`f(x)`即为函数关系。
2. Set：一组不含相同元素的有序数据集合。
3. Array：一组有序的数据集合，可以有不同类型、`undefined`等值。

## 截图如下
![console截图](console.png 'console')

![git截图](git.png 'git')

